<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>評価結果詳細 - Prototype</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>

  <body class="min-h-screen bg-[#EEF3FF] text-slate-900">
    <!-- auth guard (prototype) -->
    <script>
      if (localStorage.getItem("aas_logged_in") !== "1") {
        window.location.href = "./login.html";
      }
    </script>

    <header class="sticky top-0 z-50 bg-white/80 backdrop-blur border-b border-slate-200">
      <div class="mx-auto max-w-[1400px] px-6 py-4 flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="h-9 w-9 rounded-full bg-emerald-50 border border-emerald-200 flex items-center justify-center">
            <svg viewBox="0 0 24 24" class="h-5 w-5 text-emerald-600" fill="none" stroke="currentColor" stroke-width="2.4">
              <path d="M20 6 9 17l-5-5" />
            </svg>
          </div>
          <div class="text-lg font-extrabold tracking-tight">シミュレーション結果</div>
        </div>

        <button
          class="inline-flex items-center gap-2 rounded-xl bg-slate-700 px-5 py-3 text-white font-bold shadow hover:bg-slate-800 active:translate-y-[1px] transition"
          onclick="goBackToSimulation()"
        >
          <span aria-hidden="true">←</span>
          シミュレーションに戻る
        </button>
      </div>
    </header>

    <main class="mx-auto max-w-[1400px] px-6 py-8">
      <div class="grid grid-cols-1 lg:grid-cols-[1fr_520px] gap-6 items-start">
        <!-- LEFT: 最終投稿 -->
        <section class="rounded-2xl bg-white border border-slate-200 shadow-sm overflow-hidden">
          <div class="px-7 py-6">
            <div class="flex items-center gap-3">
              <div class="h-10 w-10 rounded-xl bg-blue-50 border border-blue-200 flex items-center justify-center">
                <svg viewBox="0 0 24 24" class="h-5 w-5 text-blue-600" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M22 2 11 13" />
                  <path d="M22 2 15 22l-4-9-9-4 20-7Z" />
                </svg>
              </div>
              <h2 class="text-xl font-extrabold">あなたの最終投稿</h2>
            </div>

            <div class="mt-5 rounded-2xl border border-blue-200 bg-blue-50/60 p-6">
              <p id="finalPost" class="whitespace-pre-wrap leading-relaxed text-slate-800">
                読み込み中…
              </p>
            </div>

            <div class="mt-5 text-sm text-slate-500">
              <span class="font-semibold text-slate-600">投稿日時:</span>
              <span id="submittedAt">—</span>
            </div>
          </div>
        </section>

        <!-- RIGHT: 評価 -->
        <aside class="space-y-6">
          <!-- 総合評価 -->
          <section class="rounded-2xl bg-white border border-slate-200 shadow-sm overflow-hidden">
            <div class="px-7 py-6">
              <div class="flex items-center gap-3">
                <div class="h-10 w-10 rounded-xl bg-emerald-50 border border-emerald-200 flex items-center justify-center">
                  <svg viewBox="0 0 24 24" class="h-5 w-5 text-emerald-600" fill="none" stroke="currentColor" stroke-width="2.2">
                    <path d="M20 6 9 17l-5-5" />
                  </svg>
                </div>
                <h3 class="text-xl font-extrabold">AIからの総合評価</h3>
              </div>

              <div class="mt-5 rounded-2xl border border-emerald-200 bg-emerald-50/40 p-6 flex items-center justify-between gap-6">
                <div>
                  <div class="text-sm text-slate-500 font-semibold">総合スコア</div>
                  <div class="mt-2 flex items-baseline gap-2">
                    <div id="overallScore" class="text-5xl font-extrabold text-emerald-600">—</div>
                    <div class="text-slate-500 font-bold">/ 100</div>
                  </div>
                </div>

                <!-- medal -->
                <div class="h-16 w-16 rounded-full bg-emerald-100 border border-emerald-200 flex items-center justify-center">
                  <svg viewBox="0 0 24 24" class="h-9 w-9 text-emerald-500" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2a7 7 0 0 0 0 14 7 7 0 0 0 0-14Z" />
                    <path d="M8 14 6 22l6-3 6 3-2-8" />
                  </svg>
                </div>
              </div>
            </div>
          </section>

          <!-- レーダーチャート -->
          <section class="rounded-2xl bg-white border border-slate-200 shadow-sm overflow-hidden">
            <div class="px-7 py-6">
              <div class="flex items-center gap-3">
                <div class="h-10 w-10 rounded-xl bg-indigo-50 border border-indigo-200 flex items-center justify-center">
                  <svg viewBox="0 0 24 24" class="h-5 w-5 text-indigo-600" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 19V5" />
                    <path d="M4 19h16" />
                    <path d="M6 15l4-6 4 3 4-7" />
                  </svg>
                </div>
                <h3 class="text-xl font-extrabold">項目別評価</h3>
              </div>

              <div class="mt-5 rounded-2xl border border-slate-200 bg-white p-4">
                <div class="relative mx-auto w-full max-w-[420px]">
                  <canvas id="radar" width="420" height="320" class="w-full h-auto"></canvas>
                </div>
              </div>
            </div>
          </section>

          <!-- 項目別コメント（縦に並ぶ） -->
          <section id="detailList" class="space-y-6"></section>
        </aside>
      </div>
    </main>

    <script>
      const STORAGE_KEY = "aas_results";

      function fmtJP(dtLike) {
        const d = new Date(dtLike);
        if (Number.isNaN(d.getTime())) return "—";
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        const hh = String(d.getHours()).padStart(2, "0");
        const mm = String(d.getMinutes()).padStart(2, "0");
        const ss = String(d.getSeconds()).padStart(2, "0");
        return `${y}/${m}/${day} ${hh}:${mm}:${ss}`;
      }

      function uid() {
        return Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);
      }

      function ensureDemoResults() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) return;

        const demo = [
          {
            id: uid(),
            scenario: "マナビDX QUEST（ケース3）",
            submittedAt: "2026-02-02T16:36:59+09:00",
            finalPost:
              "まずベテランだと、「毎年ボーナス時期に必ず何かしら投資の相談がある人」とか、「過去に何度か乗換提案に応じてくれている人」は、今年も動く可能性が高いと見て、かなり上位に持ってきます。一方で若手だと、「残高が大きい人」や「直近で購入から時間が経っている人」みたいに、割と分かりやすい数字ベースで優先度を付けがちですね。",
            overall: 12,
            rubric: {
              "AI活用の目的": { score: 5, weight: 3 },
              "現状・課題": { score: 35, weight: 5 },
              "予測対象": { score: 10, weight: 3 },
              "PoCの検証目的・範囲": { score: 0, weight: 4 },
            },
          },
        ];
        localStorage.setItem(STORAGE_KEY, JSON.stringify(demo));
      }

      function loadResults() {
        try {
          return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
        } catch {
          return [];
        }
      }

      function getResultById(id) {
        const arr = loadResults();
        return arr.find((x) => x.id === id) || null;
      }

      function fallbackResult() {
        // demo から先頭を使う
        const arr = loadResults();
        return arr[0] || null;
      }

      function goBackToSimulation() {
        // 直近のケース情報を持っていたら戻す（なければ simulation.html）
        const u = new URL(window.location.href);
        const from = u.searchParams.get("from");
        if (from) {
          window.location.href = from;
          return;
        }
        window.location.href = "./simulation.html";
      }

      // ---------- Radar chart (canvas) ----------
      function drawRadar(canvas, labels, values) {
        // values: 0-100
        const ctx = canvas.getContext("2d");
        const w = canvas.width;
        const h = canvas.height;

        ctx.clearRect(0, 0, w, h);

        const cx = w / 2;
        const cy = h / 2 + 10;
        const radius = Math.min(w, h) * 0.32;
        const levels = 4; // 25/50/75/100

        // background grid
        ctx.strokeStyle = "rgba(100,116,139,0.25)"; // slate
        ctx.lineWidth = 1;

        for (let lv = 1; lv <= levels; lv++) {
          const r = (radius * lv) / levels;
          ctx.beginPath();
          for (let i = 0; i < labels.length; i++) {
            const ang = (Math.PI * 2 * i) / labels.length - Math.PI / 2;
            const x = cx + r * Math.cos(ang);
            const y = cy + r * Math.sin(ang);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        }

        // axes + labels
        ctx.fillStyle = "rgba(71,85,105,0.85)";
        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";

        for (let i = 0; i < labels.length; i++) {
          const ang = (Math.PI * 2 * i) / labels.length - Math.PI / 2;
          const x = cx + radius * Math.cos(ang);
          const y = cy + radius * Math.sin(ang);
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(x, y);
          ctx.stroke();

          const lx = cx + (radius + 26) * Math.cos(ang);
          const ly = cy + (radius + 26) * Math.sin(ang);
          const text = labels[i];
          const tw = ctx.measureText(text).width;
          ctx.fillText(text, lx - tw / 2, ly + 4);
        }

        // value polygon
        const pts = values.map((v, i) => {
          const r = (radius * Math.max(0, Math.min(100, v))) / 100;
          const ang = (Math.PI * 2 * i) / labels.length - Math.PI / 2;
          return { x: cx + r * Math.cos(ang), y: cy + r * Math.sin(ang) };
        });

        ctx.beginPath();
        pts.forEach((p, i) => (i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)));
        ctx.closePath();

        ctx.fillStyle = "rgba(59,130,246,0.22)"; // blue fill
        ctx.strokeStyle = "rgba(59,130,246,0.9)";
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        // points
        ctx.fillStyle = "rgba(59,130,246,1)";
        pts.forEach((p) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3.2, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      // ---------- Detail cards ----------
      function progressBar(score) {
        const pct = Math.max(0, Math.min(100, score));
        return `
          <div class="mt-3 h-2 w-full rounded-full bg-slate-200 overflow-hidden">
            <div class="h-full bg-rose-500" style="width:${pct}%"></div>
          </div>
        `;
      }

      function makeDetailCard(title, weight, score, text) {
        return `
          <section class="rounded-2xl bg-white border border-slate-200 shadow-sm overflow-hidden">
            <div class="px-7 py-6">
              <div class="flex items-start justify-between gap-4">
                <div>
                  <div class="flex items-center gap-3">
                    <div class="text-lg font-extrabold">${title}</div>
                    <span class="inline-flex items-center rounded-md bg-amber-50 border border-amber-100 px-2 py-1 text-xs font-extrabold text-amber-700">
                      重み×${weight}
                    </span>
                  </div>
                </div>
                <div class="text-lg font-extrabold">${score} <span class="text-sm text-slate-400 font-bold">/ 100</span></div>
              </div>

              ${progressBar(score)}

              <div class="mt-3 text-sm text-slate-500">
                ${title === "現状・課題" ? "現場の具体的なボトルネック（工数、バイアス、過去の失敗）の解像度。" :
                   title === "AI活用の目的" ? "経営戦略に基づいたAI導入の真の意図（残高重視への転換等）を把握できているか" :
                   title === "予測対象" ? "誰を／いつのタイミングで／何を予測するか（購入・売却、翌月・翌々月など）の具体性。" :
                   "実証実験におけるデータの境界線、制約事項、ステークホルダーの特定。"}
              </div>

              <div class="mt-4 rounded-2xl border border-slate-200 bg-white p-5 text-sm leading-relaxed text-slate-800">
                ${text}
              </div>
            </div>
          </section>
        `;
      }

      function defaultFeedback(title) {
        if (title === "AI活用の目的") {
          return `今回の提出内容では、「ベテラン／若手が今どのようなロジックで顧客を選んでいるか」は書かれていますが、<b>「なぜAIを入れるのか」</b>（経営としてどんな営業スタイル・ビジネスモデルに変えたいのか）といった上位目的には触れられていません。<br><br>
          まずは営業部課長やFD推進室長に、早い段階でオープンクエスチョンを投げて確認してください。<br>
          例：「今回のAI導入で、単に訪問リスト作成を効率化したいだけでしょうか。それとも長期的にどんな営業スタイルに変えていきたい、という狙いがありますか？」<br><br>
          目的が曖昧なままだと、AIが現状のバイアスをそのまま再現するだけになりやすいです。`;
        }
        if (title === "現状・課題") {
          return `「ベテランはボーナス期に動きやすい人・乗換提案に応じやすい人を上位にする」「若手は残高が大きい人や購入から時間が経っている人など、数字ベースで優先度を付けがち」という観察は良いです。これは、担当者の経験や見やすい指標に依存した<b>経験則ベース＋バイアスのある選別</b>になっている、という課題のヒントになります。<br><br>
          一方で、次のような重要情報がまだ取れていません：<br>
          ・月次の訪問計画作成にどれくらい時間・工数がかかっているか（定量負荷）<br>
          ・そのロジックによってどの程度「取りこぼし」「空振り」が発生していると感じているか<br>
          ・若手が数字ベースになりがちな背景（スキル不足／指導方針／評価指標の影響など根本原因）<br><br>
          次は「うまくいかなかったケース」「取りこぼしの具体例」を掘り下げる質問を用意すると、AIに期待される役割がはっきりします。`;
        }
        if (title === "予測対象") {
          return `現時点では「動きやすさ」「残高」などの要素が挙がっていますが、<b>誰を／いつ／何を予測するか</b>がまだ粗いです。<br><br>
          次のように粒度を揃えて定義してみてください：<br>
          ・対象：既存顧客／休眠顧客／新規見込み どれか<br>
          ・イベント：購入／売却／乗換相談／来店 など<br>
          ・予測窓：翌月／翌々月／四半期 など<br>
          ・運用：確率上位N件を訪問候補にする／閾値を超えたら提案する など<br><br>
          この定義が固まると、必要データ（取引、提案履歴、来店、キャンペーン接触等）も連動して整理できます。`;
        }
        // PoC
        return `提出内容からは、「どの期間のデータを使うか」「対面取引に絞るのか」「PoCとしてどの支店／どの販売員を対象にするか」といった検証範囲の情報が不足しています。<br><br>
        PoCでは、最初に境界線を決めるのが重要です：<br>
        ・期間：直近24ヶ月／36ヶ月など（制度変更やキャンペーンの影響も確認）<br>
        ・対象：支店の選定理由（地域特性／顧客層／体制）<br>
        ・評価：取りこぼし／空振りのどちらを重視するか、現場の受容性（説明可能性）<br>
        ・リーク：未来情報の混入（後知恵）をどう防ぐか（分割方法）<br><br>
        まずは「PoCの成功条件」を合意し、次に「対象範囲」「制約事項」「関係者」を確定させましょう。`;
      }

      // ---------- boot ----------
      ensureDemoResults();

      const url = new URL(window.location.href);
      const id = url.searchParams.get("id");
      let item = id ? getResultById(id) : null;
      if (!item) item = fallbackResult();

      // UI set
      document.getElementById("finalPost").textContent = item?.finalPost || "（最終投稿がありません）";
      document.getElementById("submittedAt").textContent = fmtJP(item?.submittedAt);
      document.getElementById("overallScore").textContent = String(item?.overall ?? 0);

      // rubric normalize
      const labels = ["AI活用の目的", "現状・課題", "予測対象", "PoCの検証目的・範囲"];
      const rubric = item?.rubric || {};
      const values = labels.map((k) => (rubric[k]?.score ?? 0));
      const weights = labels.map((k) => (rubric[k]?.weight ?? 3));

      // radar draw
      const canvas = document.getElementById("radar");
      drawRadar(canvas, labels, values);

      // detail list
      const detailHost = document.getElementById("detailList");
      detailHost.innerHTML = labels
        .map((k, idx) => {
          const score = values[idx];
          const w = weights[idx];
          const feedback = rubric[k]?.feedback || defaultFeedback(k);
          return makeDetailCard(k, w, score, feedback);
        })
        .join("");
    </script>
  </body>
</html>
